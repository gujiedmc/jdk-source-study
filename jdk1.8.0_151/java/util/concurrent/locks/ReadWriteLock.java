/*
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

/*
 *
 *
 *
 *
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent.locks;

/**
 * 读写锁包含了一对相关联的锁，一个只读操作和一个写操作。
 * 读操作可以多个线程同时获取，只要没有写操作。写操作是独占的。
 *
 * 读写锁的实现需要保证写锁的内存影响同步给关联的读锁。
 * 也就是说，一个线程获取读锁之后会看到之前写锁释放之前的所有更新。
 *
 * 在访问共享数据是，一个读写锁的并发能达到比互斥锁更高的级别。
 * 它所造成的事实是在同一时间只有一个线程能修改共享数据，大多数情况下，任意数量的线程可以并发读取共享数据。
 *
 * 读写锁相较于互斥锁能否提高并发性能，依赖于数据读写的频率，读写操作的持续时间，数据的竞争等等，
 * 也就是同时有多少线程会分别尝试读或写数据。例如，一个集合在初始化数据之后极少修改，同时频繁查询，这就是读写锁最适用的场景。
 * 如果数据的更新很频繁，那数据的大部分时间都被写操作独占，对并发的提升几无影响。
 * 另外，如果读操作很短的话，那么读写锁实现（普遍比互斥锁复杂）会造成更大的性能开销，
 * 尤其是很多读写锁实现任然序列化所有线程通过一个很小单元的代码。
 * 最后，只有分析和测量才能确定使用读写锁是否适合您的应用。
 *
 * 尽管一个读写锁的基础操作是跟简单直白的，但是仍然有一些策略需要决定，这些可能会影响到读写锁的有效性。
 * 1. 决定当一个写操作结束时接下来是进行读操作还是写操作（假设都有）。
 * 通常是写操作优先，因为写操作被期望操作时间短且不频繁。
 * 读操作优先不常见，因为读操作频繁会导致写操作进行漫长的等待，无法及时修改数据。
 * 公平，按顺序的实现也是可以的。
 *
 * 2. 决定在读操作正在进行且已经有写操作正在等待时，新的读操作是直接执行还是进入队列等待写操作执行完。
 * 读操作优先可能会无限期的延期写操作，写操作优先可能会减少并发的潜力。
 *
 * 3. 决定锁是否可以重入。写锁是否可以重入？读锁是否可以重入？一个获取读锁的线程是否可以再次获取写锁？
 *
 * 4. 写锁是否可以降级成为读锁？读锁能否升级为写锁，优先于其他读锁或写锁？
 *
 * 实现的时候需要评估上述的问题。
 */
public interface ReadWriteLock {
    /**
     * 返回读锁
     */
    Lock readLock();

    /**
     * 返回写锁
     */
    Lock writeLock();
}
